#!/usr/bin/env python

import argparse
import json

# print(','.join(['{:d}'.format(ida_segment.get_segm_base(ida_segment.getnseg(i))) for i in range(ida_segment.get_segm_qty())]))

DESCRIPTION = 'Convert a DOSBox coverage map into Lighthouse module+offset format.'
EPILOG = """
IDA Pro uses a fake 32-bit memory map to lay out 16-bit code. In order to use a CPU coverage map from DOSBox with Lighthouse, addresses need to be converted from seg:offset_16 format to module+offset_32.
"""

if __name__ == '__main__':
    parser = argparse.ArgumentParser( description=DESCRIPTION, epilog=EPILOG )
    parser.add_argument( 'segments', type=argparse.FileType( mode='r' ), help='Segment map JSON generated by get_segtable.py' )
    parser.add_argument( 'coverage_log', type=argparse.FileType( mode='r' ), help='Coverage log taken from DOSBox: LOGC [num of instructions]' )
    parser.add_argument( '--out_file', type=argparse.FileType( mode='w' ), help='Output Lighthouse coverage file (default: stdout)', required=False )
    parser.add_argument( '--no_filter', default=False, action='store_true', help='Include non-transformed lines in output', required=False )
    args = parser.parse_args()

    seg_info = json.load( args.segments )
    base_name = seg_info['module']
    seg_map = {x['selector']: x for x in seg_info['segments']}
    fin = args.coverage_log
    fout = args.out_file

    buf = fin.readline()
    while (buf):
        seg, offset = buf.split(':', 1)
        offset = int( offset.strip(), 16 )
        if seg in seg_map:
            result = '{}+{:08x}\n'.format( base_name, seg_map[seg]['ida_offset']+offset )
        elif args.no_filter:
            result = buf
        else:
            buf = fin.readline()
            continue

        if fout:
            fout.write( result )
        else:
            print( result, end='' )
        buf = fin.readline()
    fout.close()

